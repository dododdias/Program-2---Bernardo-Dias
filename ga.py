import random
import math
import csv
from typing import List, Tuple
from schedule import (
    create_random_individual,
    evaluate_fitness,
    format_schedule,
    NUM_ACTIVITIES,
    NUM_ROOMS,
    NUM_TIMES,
    NUM_FACILITATORS,
)


POPULATION_SIZE = 250
MUTATION_RATE = 0.01
TOURNAMENT_SIZE = 3


def initialize_population() -> List[List[int]]:
    return [create_random_individual() for _ in range(POPULATION_SIZE)]


def evaluate_population(population: List[List[int]]) -> Tuple[List[float], float, float]:
    fitnesses = [evaluate_fitness(ind) for ind in population]
    avg_fitness = sum(fitnesses) / len(fitnesses)
    best_fitness = max(fitnesses)
    worst_fitness = min(fitnesses)
    return fitnesses, avg_fitness, best_fitness, worst_fitness


def softmax(fitnesses):
    """
    Converts a list of fitness values into probabilities using softmax.
    Uses numerical stability trick: subtracts the max before exp.
    """
    max_f = max(fitnesses)
    exps = [math.exp(f - max_f) for f in fitnesses]
    total = sum(exps)
    return [e / total for e in exps]


def softmax_selection(population, fitnesses):
    """
    Selects ONE individual using the probability distribution
    generated by the softmax of the fitnesses.
    """
    probs = softmax(fitnesses)
    r = random.random()
    cum = 0.0
    for i, p in enumerate(probs):
        cum += p
        if r <= cum:
            # returns a COPY of the individual
            return population[i][:]
    # fallback (in case of rounding errors)
    return population[-1][:]


def tournament_selection(population: List[List[int]], fitnesses: List[float]) -> List[int]:
    indices = random.sample(range(len(population)), TOURNAMENT_SIZE)
    best_idx = max(indices, key=lambda i: fitnesses[i])
    return population[best_idx][:]


def single_point_crossover(parent1: List[int], parent2: List[int]):
    length = len(parent1)
    point = random.randint(1, length - 1)
    child1 = parent1[:point] + parent2[point:]
    child2 = parent2[:point] + parent1[point:]
    return child1, child2


def mutate(individual, rate: float):
    """
    Mutation:
    - For each activity (gene), with probability = rate:
        randomly chooses whether to change:
          * the room, or
          * the time, or
          * the facilitator
        and draws a new VALID value from that domain.
    """

    for i in range(len(individual)):
        if random.random() < rate:
            room_idx, time_idx, fac_idx = individual[i]

            choice = random.choice(["room", "time", "fac"])

            if choice == "room":
                room_idx = random.randrange(NUM_ROOMS)
            elif choice == "time":
                time_idx = random.randrange(NUM_TIMES)
            else:  # "fac"
                fac_idx = random.randrange(NUM_FACILITATORS)

            # replace the whole gene with a new tuple
            individual[i] = (room_idx, time_idx, fac_idx)


def create_next_generation(population, fitnesses):
    new_pop = []

    while len(new_pop) < POPULATION_SIZE:
        p1 = softmax_selection(population, fitnesses)
        p2 = softmax_selection(population, fitnesses)
        c1, c2 = single_point_crossover(p1, p2)

        new_pop.append(c1)
        if len(new_pop) < POPULATION_SIZE:
            new_pop.append(c2)

    for ind in new_pop:
        mutate(ind, MUTATION_RATE)

    return new_pop


def get_best_individual(population):
    # now evaluate_population returns 4 values
    fitnesses, _, _, _ = evaluate_population(population)
    idx = max(range(len(population)), key=lambda i: fitnesses[i])
    return population[idx], fitnesses[idx]


def set_mutation_rate(rate: float):
    """
    Allows adjusting the mutation rate from outside (e.g., GUI).
    """
    global MUTATION_RATE
    MUTATION_RATE = rate


def run_genetic_algorithm(on_generation=None):
    """
    Runs the GA. If on_generation is not None, calls this callback
    every generation with:
        (generation, best_fitness, avg_fitness, worst_fitness, MUTATION_RATE)
    to allow real-time GUI/plot updates.
    """
    global MUTATION_RATE  # allows adjustments if you want
    population = initialize_population()

    # list to store metrics for CSV
    history = []

    # evaluate initial population
    fitnesses, avg_fitness, best_fitness, worst_fitness = evaluate_population(population)
    prev_avg = avg_fitness
    generation = 0

    print(
        f"Generation {generation:3d} | "
        f"Best = {best_fitness:.4f} | Avg = {avg_fitness:.4f} | Worst = {worst_fitness:.4f} | "
        f"MR = {MUTATION_RATE:.5f}"
    )

    # save first line in history
    history.append([generation, best_fitness, avg_fitness, worst_fitness, MUTATION_RATE])

    # call callback for generation 0 (if exists)
    if on_generation is not None:
        on_generation(
            generation,
            best_fitness,
            avg_fitness,
            worst_fitness,
            MUTATION_RATE,
        )

    # main loop
    while True:
        generation += 1

        # create next generation from current one
        population = create_next_generation(population, fitnesses)

        # evaluate new population
        fitnesses, avg_fitness, best_fitness, worst_fitness = evaluate_population(population)

        improvement = (avg_fitness - prev_avg) / abs(prev_avg) if prev_avg != 0 else 0

        # Example of optional mutation rate adjustment:
        # if generation % 20 == 0 and generation >= 40 and improvement > 0 and MUTATION_RATE > 0.0001:
        #     MUTATION_RATE /= 2
        #     print(f"*** Mutation rate reduced to {MUTATION_RATE:.5f}")

        print(
            f"Generation {generation:3d} | "
            f"Best = {best_fitness:.4f} | Avg = {avg_fitness:.4f} | Worst = {worst_fitness:.4f} | "
            f"Improvement = {improvement * 100:.2f}% | MR = {MUTATION_RATE:.5f}"
        )

        # save this generation in history
        history.append([generation, best_fitness, avg_fitness, worst_fitness, MUTATION_RATE])

        # callback for GUI / plots
        if on_generation is not None:
            on_generation(
                generation,
                best_fitness,
                avg_fitness,
                worst_fitness,
                MUTATION_RATE,
            )

        # stopping criterion
        if generation >= 100 and improvement < 0.01:
            print("\nStopping criterion reached.")
            break

        prev_avg = avg_fitness

    # get best final individual
    best, best_fit = get_best_individual(population)

    # save schedule to txt
    with open("output_schedule.txt", "w") as f:
        f.write("Best individual:\n")
        f.write(format_schedule(best))
        f.write(f"\nBest fitness: {best_fit}\n")
        f.write(f"Generations: {generation}\n")
        f.write(f"Final mutation rate: {MUTATION_RATE}\n")

    # SAVE CSV (mandatory)
    with open("fitness_history.csv", "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["Generation", "BestFitness", "AvgFitness", "WorstFitness", "MutationRate"])
        writer.writerows(history)

    print("\nFile 'fitness_history.csv' saved successfully!")

    return best, best_fit
